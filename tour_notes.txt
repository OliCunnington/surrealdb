<decimal>1000.00000000000001;
-- 1000dec

1000.00000000000001dec;
-- 1000.00000000000001dec

-- Works
<datetime>'1859-11-26';
-- Returns an error
<datetime>'EIGHTEEN FIFTY NINE, NOVEMBER TWENTY SIX';
-- Works
d'1859-11-26';
-- Query won't even run
d'EIGHTEEN FIFTY NINE, NOVEMBER TWENTY SIX';


UPDATE can be used to change fields (and add new ones... if SHEMALESS)

settings a field value to an id (SET whatever = place:surreal_library) creates a link
    can be list etc...


LET
-- Easy to read: this will be IDs of towns with the name Riverdale
LET $riverdale = SELECT VALUE id FROM town WHERE name = "Riverdale";

-- IDs of libraries with the name Riverdale in the address
LET $libraries = SELECT VALUE id FROM place WHERE "Riverdale" IN address;

-- Then update one with the other
UPDATE $riverdale SET libraries = $libraries;

-- Parameter is still around for reuse
-- If we had any cats we could link them to the libraries too
UPDATE cat SET libraries = $libraries;

SELECT *, libraries.name FROM town;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          name: [
--            'Surreal Library'
--          ]
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]

SELECT 
    *, 
    libraries.{ name, floors }
FROM town;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          floors: 8,
--          name: 'Surreal Library'
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]


-- use FETCH to display all the fields of a linked record
SELECT * FROM town FETCH libraries;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          address: '2025 Statement Street, Riverdale',
--          floors: 8,
--          id: place:surreal_library,
--          name: 'Surreal Library',
--          place_type: 'library'
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]

 -- SHEMAFULL
 DEFINE TABLE schemafull_town SCHEMAFULL;
-- schemafull_town only has one defined field
DEFINE FIELD population ON schemafull_town TYPE number;

-- So the query succeeds, but 'name' data is ignored
CREATE schemafull_town SET name = "Riverdale", population = 75000;

-- SHEMALESS table can use define to restrict types for fields
-- Statements for the 'place' table
DEFINE FIELD address ON place TYPE string;
DEFINE FIELD name ON place TYPE string;

-- Statements for the 'town' table
DEFINE FIELD name ON town TYPE string;
DEFINE FIELD population ON town TYPE int;
DEFINE FIELD libraries ON town TYPE option<array<record<place>>>;

-- Records are always of type record<record_name>
-- array<...> able to hold more than one
-- option<...> allows for empty field / record creation without populated field

-- defines allowed values for a field
DEFINE FIELD place_type
    ON place
    TYPE "building" | "tower" | "store" | "school" | "park" | "library";

-- does the same thing
DEFINE FIELD place_type
    ON town
    TYPE string
    ASSERT $value IN ["building", "tower", "store", "school", "park", "library"];

-- dissalows negative population
DEFINE FIELD OVERWRITE population ON town TYPE int ASSERT $value >= 0;
-- use the OVERWRITE clause to rewrite the definition

--works fine, but returns NONE
LET $name = town:riverdale.naame;
--catches type mis-match
LET $name: string = town:riverdale.naame;
--  'Found NONE for param $name, but expected a string'


-- type restriction can be used in assignment
LET $type: "building" | "school" | "park" = place:surreal_library.place_type;
--  "Found 'library' for param $type, but expected a 'building' | 'school' | 'park'"


-- literal types can use combinations -> ENUMS and TAGGED UNIONS (?!)
LET $result: 
    "Good"
    | { error_type: "Bad gateway" | "Unauthorized", message: string } 
= { error_type: "Unauthorized", message: "Can't be accessed at this time" };

RETURN $result;

--  {
--    error_type: 'Unauthorized',
--    message: "Can't be accessed at this time"
--  }


