<decimal>1000.00000000000001;
-- 1000dec

1000.00000000000001dec;
-- 1000.00000000000001dec

-- Works
<datetime>'1859-11-26';
-- Returns an error
<datetime>'EIGHTEEN FIFTY NINE, NOVEMBER TWENTY SIX';
-- Works
d'1859-11-26';
-- Query won't even run
d'EIGHTEEN FIFTY NINE, NOVEMBER TWENTY SIX';


UPDATE can be used to change fields (and add new ones... if SHEMALESS)

settings a field value to an id (SET whatever = place:surreal_library) creates a link
    can be list etc...


LET
-- Easy to read: this will be IDs of towns with the name Riverdale
LET $riverdale = SELECT VALUE id FROM town WHERE name = "Riverdale";

-- IDs of libraries with the name Riverdale in the address
LET $libraries = SELECT VALUE id FROM place WHERE "Riverdale" IN address;

-- Then update one with the other
UPDATE $riverdale SET libraries = $libraries;

-- Parameter is still around for reuse
-- If we had any cats we could link them to the libraries too
UPDATE cat SET libraries = $libraries;

SELECT *, libraries.name FROM town;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          name: [
--            'Surreal Library'
--          ]
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]

SELECT 
    *, 
    libraries.{ name, floors }
FROM town;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          floors: 8,
--          name: 'Surreal Library'
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]


-- use FETCH to display all the fields of a linked record
SELECT * FROM town FETCH libraries;

--  [
--    {
--      id: town:riverdale,
--      libraries: [
--        {
--          address: '2025 Statement Street, Riverdale',
--          floors: 8,
--          id: place:surreal_library,
--          name: 'Surreal Library',
--          place_type: 'library'
--        }
--      ],
--      name: 'Riverdale',
--      population: 75000
--    }
--  ]

 -- SHEMAFULL
 DEFINE TABLE schemafull_town SCHEMAFULL;
-- schemafull_town only has one defined field
DEFINE FIELD population ON schemafull_town TYPE number;

-- So the query succeeds, but 'name' data is ignored
CREATE schemafull_town SET name = "Riverdale", population = 75000;

-- SHEMALESS table can use define to restrict types for fields
-- Statements for the 'place' table
DEFINE FIELD address ON place TYPE string;
DEFINE FIELD name ON place TYPE string;

-- Statements for the 'town' table
DEFINE FIELD name ON town TYPE string;
DEFINE FIELD population ON town TYPE int;
DEFINE FIELD libraries ON town TYPE option<array<record<place>>>;

-- Records are always of type record<record_name>
-- array<...> able to hold more than one
-- option<...> allows for empty field / record creation without populated field

-- defines allowed values for a field
DEFINE FIELD place_type
    ON place
    TYPE "building" | "tower" | "store" | "school" | "park" | "library";

-- does the same thing
DEFINE FIELD place_type
    ON town
    TYPE string
    ASSERT $value IN ["building", "tower", "store", "school", "park", "library"];

-- dissalows negative population
DEFINE FIELD OVERWRITE population ON town TYPE int ASSERT $value >= 0;
-- use the OVERWRITE clause to rewrite the definition

--works fine, but returns NONE
LET $name = town:riverdale.naame;
--catches type mis-match
LET $name: string = town:riverdale.naame;
--  'Found NONE for param $name, but expected a string'


-- type restriction can be used in assignment
LET $type: "building" | "school" | "park" = place:surreal_library.place_type;
--  "Found 'library' for param $type, but expected a 'building' | 'school' | 'park'"


-- literal types can use combinations -> ENUMS and TAGGED UNIONS (?!)
LET $result: 
    "Good"
    | { error_type: "Bad gateway" | "Unauthorized", message: string } 
= { error_type: "Unauthorized", message: "Can't be accessed at this time" };

RETURN $result;

--  {
--    error_type: 'Unauthorized',
--    message: "Can't be accessed at this time"
--  }


INSERT INTO table_name [
    {
        JSON ACCEPTED HERE
    }
]

INSERT INTO person [
    {
        "name": "Sara Bellum",
        "age": 30        
    }
]
--  [
--    {
--      age: 30,
--      id: person:jbcyzmur1jalageanc1u,
--      name: 'Sara Bellum'
--    }
--  ]


--- FOR LOOPS

FOR $person IN [
  {
    age: 30,
    name: 'Sara Bellum'
  },
  {
    age: 25,
    name: 'Lydia Wyndham'
  },
  {
    age: 45,
    name: 'Samm Schwartz'
  }
] {
    CREATE person SET
        age = $person.age,
        name = $person.name
};

SELECT * FROM person;


--  [
--    {
--      age: 45,
--      id: person:cj8wc617o1ea2vs1yv4n,
--      name: 'Samm Schwartz'
--    },
--    {
--      age: 30,
--      id: person:e8z6pjqhuwzfalbku61n,
--      name: 'Sara Bellum'
--    },
--    {
--      age: 25,
--      id: person:faovorn8ntkqwfw01638,
--      name: 'Lydia Wyndham'
--    }
--  ]


-- GRAPH RELATIONS

UPDATE town:riverdale SET libraries = [place:surreal_library];
-- creates link, does not allow for meta data

-- table -> meta_data -> table_two
-- table <- meta_data <- table_two

-- Create writer->wrote->blog path
RELATE writer:one->wrote->blog:one;
--  [
--    {
--      id: wrote:7l04nq3umzufbemaldlz,
--      in: writer:one,
--      out: blog:one
--    }
--  ]

-- Create reader->likes->magazine path
RELATE reader:one->likes->magazine:one
    SET stars_out_of_ten = 7.5; -- and give it a field too if we want
--  [
--    {
--      id: likes:jd17lotl4nnyf06jl2ng,
--      in: reader:one,
--      out: magazine:one,
--      stars_out_of_ten: 7.5f
--    }
--  ]

--inside FOR loop 
FOR $person IN [
  {
    age: 30,
    name: 'Sara Bellum'
  },
  {
    age: 25,
    name: 'Lydia Wyndham'
  },
  {
    age: 45,
    name: 'Samm Schwartz'
  }
] {
    LET $created = CREATE ONLY person SET
        age = $person.age,
        name = $person.name;
    RELATE $created->works_at->place:surreal_library;
};

SELECT * FROM works_at;
--  [
--    {
--      id: works_at:3o8n3jmqx1uok41rjxq7,
--      in: person:g94fc1nqsraaatplddyh,
--      out: place:surreal_library
--    },
--    {
--      id: works_at:f3ghd88elmvs1jwfhpoc,
--      in: person:qpk3htqruhvd469pox0r,
--      out: place:surreal_library
--    },
--    {
--      id: works_at:j2yf2jdnmponak0v3q0q,
--      in: person:6kittp2n5lwpjzgu29jt,
--      out: place:surreal_library
--    }
--  ]

SELECT in.* FROM works_at;
--  [
--    {
--      in: {
--        age: 45,
--        id: person:f0z8cabmok8m9xn00lfu,
--        name: 'Samm Schwartz'
--      }
--    },
--    {
--      in: {
--        age: 30,
--        id: person:zfdzeawmuqh2mm498edj,
--        name: 'Sara Bellum'
--      }
--    },
--    {
--      in: {
--        age: 25,
--        id: person:ocp2l14l4nbgo60mnhgt,
--        name: 'Lydia Wyndham'
--      }
--    }
--  ]

-- using graph query directly on a record
-- Get Samm's record ID
LET $samm = SELECT id FROM ONLY person WHERE name = 'Samm Schwartz' LIMIT 1;

-- Then just query from the record ID, no SELECT
$samm->works_at->place.{ address, floors, name };
--  [
--    {
--      address: '2025 Statement Street, Riverdale',
--      floors: 8,
--      name: 'Surreal Library'
--    }
--  ]

-- bidirectional relations
place:surreal_library<-works_at<-person.name;
--  [
--    'Samm Schwartz',
--    'Sara Bellum',
--    'Lydia Wyndham'
--  ]

-- multi-level relations
CREATE hero:wolverine, hero:jean_grey, hero:cyclops;
RELATE hero:wolverine->likes->hero:jean_grey;
RELATE hero:jean_grey->likes->hero:cyclops;

-- returns Jean Grey, whom Wolverine likes
hero:wolverine->likes->hero;
-- returns Cyclops, whom the person that Wolverine likes likes
hero:wolverine->likes->hero->likes->hero;

--valid 
person->works_at->place<-works_at<-person

-- querry with list of related (team_members) persons
SELECT 
    name, 
    ->works_at->place
    <-works_at<-person.name 
    AS team_members
FROM person;
--  [
--    {
--      name: 'Sara Bellum',
--      team_members: [
--        'Samm Schwartz',
--        'Sara Bellum',
--        'Lydia Wyndham'
--      ]
--    },
--    {
--      name: 'Lydia Wyndham',
--      team_members: [
--        'Samm Schwartz',
--        'Sara Bellum',
--        'Lydia Wyndham'
--      ]
--    },
--    {
--      name: 'Samm Schwartz',
--      team_members: [
--        'Samm Schwartz',
--        'Sara Bellum',
--        'Lydia Wyndham'
--      ]
--    }
--  ]

-- array::complement() example
SELECT 
    name, 
  -- The function takes two arrays, so put 'name' inside an array
    array::complement(->works_at->place<-works_at<-person.name, [name])
    AS team_members
FROM person;
--  [
--    {
--      name: 'Lydia Wyndham',
--      team_members: [
--        'Sara Bellum',
--        'Samm Schwartz'
--      ]
--    },
--    {
--      name: 'Sara Bellum',
--      team_members: [
--        'Lydia Wyndham',
--        'Samm Schwartz'
--      ]
--    },
--    {
--      name: 'Samm Schwartz',
--      team_members: [
--        'Lydia Wyndham',
--        'Sara Bellum'
--      ]
--    }
--  ]

array::complement(
    ["He", "is", "almost", "always", "on", "time"],
    ["always", "almost"]
);
--  [
--    'He',
--    'is',
--    'on',
--    'time'
--  ]

-- array::complement with a customer->purchased->product<-purchased<-customer would give basic recomendations ?


-- automatically generated field on account/record creation recording time, readonly
DEFINE FIELD account_created ON TABLE customer_of VALUE time::now() READONLY;

-- field for last update (not read only but populated on creation) 
DEFINE FIELD last_updated ON TABLE customer_of VALUE time::now();

-- calculated field
DEFINE FIELD customer_for
  ON TABLE customer_of
  VALUE <future> { time::now() - account_created };



FOR $data IN [
  { age: 15, name: 'Archie Andrews'   },
  { age: 15, name: 'Veronica Lodge'   },
  { age: 15, name: 'Betty Cooper'     },
  { age: 15, name: 'Jughead Jones'    },
  { age: 15, name: 'Reggie Mantle'    },
  { age: 50, name: 'Hiram P. Lodge'   },
    { age: 55, name: 'Geraldine Grundy' },
  { age: 65, name: 'Waldo Weatherbee' }
] {
    LET $person = CREATE ONLY person SET
        name = $data.name,
        age = $data.age;
    RELATE $person->customer_of->place:surreal_library;
};

SELECT 
  out.name AS customer_of,
  account_created,
  customer_for,
  last_updated
FROM customer_of LIMIT 1;

--  [
--    {
--      account_created: d'2025-03-19T05:26:14.912Z',
--      customer_for: 1ms,
--      customer_of: 'Surreal Library',
--      last_updated: d'2025-03-19T05:26:14.912Z'
--    }
--  ]

SLEEP 1s;

SELECT 
  out.name AS customer_of,
  account_created,
  customer_for,
  last_updated
FROM customer_of LIMIT 1;

--  [
--    {
--      account_created: d'2025-03-19T05:26:14.912Z',
--      customer_for: 1s3ms,
--      customer_of: 'Surreal Library',
--      last_updated: d'2025-03-19T05:26:14.912Z'
--    }
--  ]


FOR $data IN 
[
  {
    author: 'Charles Dickens',
    english_title: 'A Tale of Two Cities',
    language: 'en',
    published: "1859-11-26",
    title: 'A Tale of Two Cities'
  },
    {
        author: "Antoine de Saint-Exupéry",
        english_title: "The Little Prince",
        language: "fr",
        published: "1943-04-15",
        title: "Le Petit Prince"
    },
  {
    author: 'Paulo Coelho',
    english_title: 'The Alchemist',
    language: 'pt',
    published: "1988-03-01",
    title: 'O Alquimista'
  },
  {
    author: 'J.K. Rowling',
    english_title: "Harry Potter and the Philosopher's Stone",
    language: 'en',
    published: "1997-06-26",
    title: "Harry Potter and the Philosopher's Stone"
  },
  {
    author: 'Agatha Christie',
    english_title: 'And Then There Were None',
    language: 'en',
    published: "1939-11-06",
    title: 'And Then There Were None'
  },
  {
    author: 'Cao Xueqin',
    english_title: 'Dream of the Red Chamber',
    language: 'zh',
    published: "1791-03-01",
    title: '紅樓夢'
  },
  {
    author: 'J.R.R. Tolkien',
    english_title: 'The Hobbit',
    language: 'en',
    published: "1937-09-21",
    title: 'The Hobbit'
  },
  {
    author: 'Lewis Carroll',
    english_title: "Alice's Adventures in Wonderland",
    language: 'en',
    published: "1865-07-04",
    title: "Alice's Adventures in Wonderland"
  }
] {
    -- Create the author for each book, return just the object
    LET $author = CREATE ONLY person SET
      name = $data.author;

    -- Create the book, cast 'published' field from string to datetime
    LET $book = CREATE ONLY book SET
        author = $data.author,
        english_title = $data.english_title,
        language = $data.language,
        published = <datetime>$data.published,
        title = $data.title;

    -- Connect the author to the book
    RELATE $author->wrote->$book;
    -- Give the book to the library
    RELATE place:surreal_library->has->$book;
};

SELECT 
  name AS author, 
  ->wrote->book.title AS books
FROM person
  WHERE ->wrote->book
  LIMIT 3;

--  [
--    {
--      author: 'J.R.R. Tolkien',
--      books: [
--        'The Hobbit'
--      ]
--    },
--    {
--      author: 'Agatha Christie',
--      books: [
--        'And Then There Were None'
--      ]
--    },
--    {
--      author: 'Lewis Carroll',
--      books: [
--        "Alice's Adventures in Wonderland"
--      ]
--    }
--  ]

SELECT 
  name, 
  ->has.out.title AS books
FROM place;

--  [
--    {
--      books: [
--        'The Hobbit',
--        'And Then There Were None',
--        'A Tale of Two Cities',
--        "Harry Potter and the Philosopher's Stone",
--        'Le Petit Prince',
--        "Alice's Adventures in Wonderland",
--        '紅樓夢',
--        'O Alquimista'
--      ],
--      name: 'Surreal Library'
--    }
--  ]

-- EVENTS
DEFINE EVENT event_name ON table_name [ WHEN some_expression ] THEN {
   // Write what you want to happen here
};

-- access to the type of event [“CREATE”, “UPDATE”, “DELETE”] through $event parameter
-- also $before and $after

-- set english_title to be title if language is 'en' or throw error if language not 'en' and english_title not populated
DEFINE EVENT language_check ON book WHEN $event = "CREATE" THEN {
    IF $after.language = 'en' {
        UPDATE $after SET english_title = $after.title;
    } ELSE IF $after.language != 'en' AND $after.english_title IS NONE {
        THROW "Please enter an English title for " 
            + <string>$after.title + 
            " written in "
            + <string>$after.language;
    }
};

CREATE book SET title = "The Shadow Rising", author = "Robert Jordan", language = 'en';
--  [
--    {
--      author: 'Robert Jordan',
--      id: book:w8e6dv2db255h27ezrip,
--      language: 'en',
--      title: 'The Shadow Rising'
--    }
--  ]

SELECT * FROM book WHERE title = "The Shadow Rising";
--  [
--    {
--      author: 'Robert Jordan',
--      english_title: 'The Shadow Rising',
--      id: book:w8e6dv2db255h27ezrip,
--      language: 'en',
--      title: 'The Shadow Rising'
--    }
--  ]

-- this will fail
CREATE book SET
    title = "La Détresse et l'enchantement",
    author = "Gabrielle Roy",
    language = 'fr';
--  "An error occurred: Please enter an English title 
--  for La Détresse et l'enchantement written in fr"

SELECT * FROM book WHERE title = "La Détresse et l'enchantement";
--  []


-- INDEXES

CREATE person SET name = "Billy";
-- Create 25000 more records, each with a random string for a name
CREATE |person:25000| SET name = rand::string(10) RETURN NONE;

-- Lots of 'person' records to look through...
SELECT * FROM person WHERE name = "Billy";

-- Add an index
DEFINE INDEX name_index ON person FIELDS name;
-- The same query is much faster now
SELECT * FROM person WHERE name = "Billy";


-- INDEXES can be used to ensure uniqueness
DEFINE INDEX unique_address ON TABLE place FIELDS address UNIQUE;
CREATE place SET
    name = "Wrong house",
    address = "2025 Statement Street, Riverdale",
    place_type = "building";
--  "Database index `unique_address` already contains
--  '2025 Statement Street, Riverdale', with record `place:surreal_library`"

-- can be used on relations/graph edges too
DEFINE INDEX can_only_like_once ON TABLE likes FIELDS in, out UNIQUE;
RELATE person:one->likes->person:two;
RELATE person:one->likes->person:two;
--  'Database index `can_only_like_once` already contains
--  [person:one, person:two], with record `likes:6lx7cqzesfh9jkic60c2`'

-- SCHEMA improvements
-- from -> to image on https://surrealdb.com/learn/tour/page-26
DEFINE TABLE OVERWRITE works_at TYPE RELATION IN person OUT place;
DEFINE TABLE OVERWRITE wrote TYPE RELATION IN person OUT book;
DEFINE TABLE OVERWRITE has TYPE RELATION IN place OUT book;
DEFINE TABLE OVERWRITE customer_of TYPE RELATION IN person OUT place;

-- DEFINE TABLE
--  TYPE RELATION                   -- to ensure that it can only be used as a graph table
--  IN record_name OUT record_name  -- to set the record types that can be used
--  OVERWRITE                       -- after DEFINE TABLE since current tables are schemaless, non-relation tables
                                    -- without this, database will throw 'already exists' error


-- RECURSIVE NOTATION
-- for exploring graph relations

--reference querry
place:event_junction.connected_to;
--  [
--    street:index_avenue,
--    street:rust_row
--  ]

-- the same, but first result returns seperate array element for each result from first step
place:event_junction.connected_to.connected_to;
--  [
--    [
--      place:event_junction,
--      place:surreal_square,
--      place:surrealdb_university,
--      street:bowler_hat_alley,
--      street:record_link_way,
--      street:rust_row,
--      street:statement_street
--    ],
--    [
--      place:idiom_tower,
--      place:transaction_trail,
--      street:bowler_hat_alley,
--      street:index_avenue,
--      street:schema_boulevard
--    ]
--  ]

-- returns single element array with all possible 
-- {search_depth}
place:event_junction.{2}.connected_to;
--  [
--    place:event_junction,
--    place:surreal_square,
--    place:surrealdb_university,
--    street:bowler_hat_alley,
--    street:record_link_way,
--    street:rust_row,
--    street:statement_street,
--    place:idiom_tower,
--    place:transaction_trail,
--    street:bowler_hat_alley,
--    street:index_avenue,
--    street:schema_boulevard
--  ]

-- {search_depth} can take range {..6}
-- {n+path} to show all the paths walked
-- {n+collect} to collect all the unique records walked along the path
-- {n+shortest+some_record_id} to show the shortest path to get to a certain record

place:idiom_tower.{3+path}.connected_to;
-- snippet
--  [
--    [
--      street:bowler_hat_alley,
--      street:index_avenue,
--      place:event_junction
--    ],
--    [
--      street:bowler_hat_alley,
--      street:index_avenue,
--      place:surreal_square
--    ]
--  ]

-- all visitable places in 3 steps
place:idiom_tower.{3+collect}.connected_to;
--  [
--    street:bowler_hat_alley,
--    street:rust_row,
--    street:schema_boulevard,
--    street:index_avenue,
--    place:idiom_tower,
--    place:transaction_trail,
--    place:access_court,
--    street:recursive_crossing,
--    place:event_junction,
--    place:surreal_square,
--    place:surrealdb_university,
--    street:record_link_way,
--    street:statement_street
--  ]

-- +shortest requires id for destination and range for max search depth
place:idiom_tower.{..6+shortest=street:push_to_main_street}.connected_to;
--  [
--    street:bowler_hat_alley,
--    street:index_avenue,
--    street:record_link_way,
--    street:push_to_main_street
--  ]

-- same querry, include original record with +inclusive
-- and .. for open range
place:idiom_tower.{..+shortest=street:push_to_main_street+inclusive}.connected_to;
--  [
--    place:idiom_tower,
--    street:bowler_hat_alley,
--    street:index_avenue,
--    street:record_link_way,
--    street:push_to_main_street
--  ]

-- notation
place:idiom_tower.{2+collect}.connected_to;
-- as querry
-- @. means "starting from whichever record ID this happens to be"
SELECT @.{2+collect}.connected_to FROM place:idiom_tower;
-- [
--   {
--     connected_to: [
--       street:bowler_hat_alley,
--       street:rust_row,
--       street:schema_boulevard,
--       street:index_avenue,
--       place:idiom_tower,
--       place:transaction_trail,
--       place:access_court,
--       street:recursive_crossing
--     ]
--   }
--  ]

-- Both of these have the same output
place:idiom_tower.{2+collect}.connected_to;
SELECT VALUE @.{2+collect}.connected_to FROM ONLY place:idiom_tower;

place:idiom_tower.{ id, name };
-- Same output using SELECT:
-- SELECT @.{ id, name } FROM ONLY place:idiom_tower;

place:idiom_tower.{ id, name, connected_to };
-- Same output using SELECT:
-- SELECT @.{ id, name, connected_to } FROM ONLY place:idiom_tower;

place:idiom_tower.{3}.{ id, name, next: connected_to.@ };
--  Same output using SELECT:
--    SELECT @.{3}.{ id, name, next: connected_to.@ } FROM ONLY place:idiom_tower;
--  output is a single object that goes down three levels, showing the id, name, and next paths

-- maximum level of depth for recursive queries (256)
-- querry above will hit this if given {..} (open_range)

-- TIMEOUT can be used if unsure of depth (with SELECT)
SELECT @.{..}.{ id, name, connected_to: connected_to.@ }
  FROM ONLY place:idiom_tower
  TIMEOUT 1s;
